clear all; close all; clc;
% Initialize ROS 2 node and publishers
movementNode = ros2node('/movement_publisher_node');
twistPub1 = ros2publisher(movementNode,'/tb3_1/cmd_vel','geometry_msgs/Twist');
twistMsg1 = ros2message('geometry_msgs/Twist');
twistPub2 = ros2publisher(movementNode,'/tb3_0/cmd_vel','geometry_msgs/Twist');
twistMsg2 = ros2message('geometry_msgs/Twist');

% Subscribers
arucoSub = ros2subscriber(movementNode, '/aruco_coordinates', 'std_msgs/Float64MultiArray');
odomSub1 = ros2subscriber(movementNode, '/tb3_1/odom', 'nav_msgs/Odometry');
odomSub2 = ros2subscriber(movementNode, '/tb3_0/odom', 'nav_msgs/Odometry');

%% Tiempo
tf = 50;
t = 0;
dt = 0.1;

%% Estados Iniciales de Robots
% Leer pos inicial robots
[arucoSubMsg, status, statusText] = receive(arucoSub,5);

% Robot 1
% p1 = [rand()*4-2; rand()*4-2];
p1 = [0; 0];
theta1 = 0;

% Robot 2
% p2 = [rand()*4-2; rand()*4-2];kpd
p2 = [0; 0];
theta2 = 0;

% Set initial position and previous variables
if not(isempty(arucoSubMsg.data))
    p2 = [arucoSubMsg.data(1); arucoSubMsg.data(2)] / 1000.0;
    theta2 = arucoSubMsg.data(3);
    
    if length(arucoSubMsg.data) > 3
        p1 = [arucoSubMsg.data(4); arucoSubMsg.data(5)] / 1000.0;
        theta1 = arucoSubMsg.data(6);
    end    
end

% Robot Lider (Virtual)
pl = [0.0; 0.2];
thetal = 0;

%% Objetivos Lider (Robot Virtual)
x_path = [0.0,     0.5,    0.5     ];
y_path = [0.2,     0.2,    0.2     ];
counter = 1;    % Contador para elegir que punto objetivo hay que seguir

% Posiciones deseadas
pd1 = [0; 0];
pd2 = [0; 0];
pdl = [0; 0];

%% Ganancias
kpd = 5.5;
kpr = 1;

%% Variables
dd = 0.1;         % Distancia entre robots
vMax = 0.15;
wMax = 1*pi;

% tic
while t < tf         

    pd1 = [ pl(1)+dd*cos(thetal+pi/2) ; pl(2)+dd*sin(thetal+pi/2)       ];
    pd2 = [ pl(1)+dd*cos(thetal-pi/2) ; pl(2)+dd*sin(thetal-pi/2)   ];
    pdl = [ x_path(counter)      ; y_path(counter)       ];

    %% Cálculo de errores
    d_l = norm(pl-pdl);        % Distancia líder pos objetivo
    d_1l = norm(p1-pl);        % Distancia robot 1 a líder
    d_1d = norm(p1-pd1);       % Distancia robot 1 a pos objetivo
    d_2l = norm(p2-pl);        % Distancia robot 2 a lider
    d_2d = norm(p2-pd2);       % Distancia robot 2 a pos objetivo
    
    de_1 = d_1l - dd;   % Error distancia robot 1
    de_2 = d_2l - dd;   % Error distancia robot 2 

    thetald = atan2( ( pdl(2) - pl(2) ), ( pdl(1) - pl(1) ) );

    thetael = thetal - thetald;
    if abs(thetael) > pi
        thetael = thetael - sign(thetael)*2*pi;
    end

    if abs(thetael) > pi/2
        % Reverse direction
         thetael = thetael - sign(thetael) * pi;
         d_l = -d_l;
    end  

    %% Leyes de control Velocidad
    v1_d = -vMax* tanh( ( ( ( kpd*d_1d )^3 ) / vMax )^1 ) * ( ( p1 - pd1 ) / d_1d );
    v1_l = -vMax* tanh( ( ( ( kpd*de_1 )^3 ) / vMax )^1 ) * ( ( p1 - pl )  / d_1l );
    v1 = v1_d + v1_l;
    
    v2_d = -vMax* tanh( ( ( ( kpd*d_2d )^3 ) / vMax )^1 ) * ( ( p2 - pd2 ) / d_2d );
    v2_l = -vMax* tanh( ( ( ( kpd*de_2 )^3 ) / vMax )^1 ) * ( ( p2 - pl )  / d_2l );
    v2 = v2_d + v2_l;

    vl = vMax* tanh( ( 0.5*kpd*d_l ) / vMax);
    
    %% Cálculo de referencias
    theta1d = atan2( v1(2), v1(1) );
    theta2d = atan2( v2(2), v2(1) );

    %% Cálculo de errores
    thetae1 = theta1 - theta1d;
    if abs(thetae1) > pi
        thetae1 = thetae1 - sign(thetae1)*2*pi;
    end

    thetae2 = theta2 - theta2d;
    if abs(thetae2) > pi
        thetae2 = thetae2 - sign(thetae2)*2*pi;
    end
    
    %% Condicional para reversa
    v1_norm = norm(v1);
    v2_norm = norm(v2);

    if v1_norm > vMax
        v1_norm = vMax;
    end

    if v2_norm > vMax
        v2_norm = vMax;
    end

    [thetae1, v1_norm] = differential_reverse(thetae1, v1_norm);
    [thetae2, v2_norm] = differential_reverse(thetae2, v2_norm);

    %% Leyes de control velocidad angular
    if abs(v1_norm) < 0.01
        w1 = 0;
    else
        w1 = -wMax * tanh( ( kpr*thetae1 )^3 / wMax);
    end

    if abs(v2_norm) < 0.01
        w2 = 0;
    else
        w2 = -wMax * tanh( ( kpr*thetae2 )^3 / wMax);
    end

    if abs(w1) > 0.02
        v1_norm = 0;
    end
    
    if abs(w2) > 0.02
        v2_norm = 0;
    end

    wl = -wMax * tanh( ( kpr*thetael )^3 / wMax);
    
    if abs(thetael) > pi/32
        vl = 0;
    else
        vl = vMax* tanh( ( kpd*d_l ) / vMax);
    end
    
    fprintf('Velocidad robot 1: %f\n', v1_norm);
    fprintf('Distancia robot 1: [de=%f, d_1d=%f]\n', de_1, d_1d);
    fprintf('Velocidad angular 1: %f\n', w1);
    fprintf('Theta error 1: %f\n',thetae1);

    % fprintf('Velocidad robot 2: %f\n', v2_norm);
    % fprintf('Distancia robot 2: [de=%f, d_2d=%f]\n', de_2, d_2d);
    % fprintf('Velocidad angular 2: %f\n', w2);
    % fprintf('Theta error 2: %f\n',thetae2);

    twistMsg2.linear.x = v1_norm;
    twistMsg2.angular.z = -w1;
    twistMsg1.linear.x = v2_norm;
    twistMsg1.angular.z = -w2;
     
    twistMsg1.linear.x = 0;
    twistMsg1.angular.z = 0;
    twistMsg2.linear.x = 0;
    twistMsg2.angular.z = 0;

    
    %% Datos de la cámara
    [arucoSubMsg, status, statusText] = receive(arucoSub,1);
    
    %% Datos de Odometría
    [odomSubMsg1, status, statusText] = receive(odomSub1,1);
    [odomSubMsg2, status, statusText] = receive(odomSub2,1);

    odomOrientation1 = odomSubMsg1.pose.pose.orientation;
    odomOrientation2 = odomSubMsg2.pose.pose.orientation;

    yaw_odom1 = atan2( 2 * ( odomOrientation1.w * odomOrientation1.z + odomOrientation1.x * odomOrientation1.y ), ...
        );
        self.yaw_odom = math.atan2(2 * (orientation.w * orientation.z + orientation.x * orientation.y),
                              1 - 2 * (orientation.y * 2 + orientation.z * 2))

    % disp(arucoSubMsg.data);
    if not(isempty(arucoSubMsg.data))
        p2 = p2 + ( [arucoSubMsg.data(1); arucoSubMsg.data(2)] / 1000.0 ) - p2;
        fprintf('Delta p2:\n');
        disp(( [arucoSubMsg.data(1); arucoSubMsg.data(2)] / 1000.0 ) - p2);
        theta2 = theta2 + arucoSubMsg.data(3) - theta2;

        if length(arucoSubMsg.data) > 3 
            p1 = p1 + ( [arucoSubMsg.data(4); arucoSubMsg.data(5)] / 1000.0 ) - p1;
            fprintf('Delta p1:\n');
            disp(( [arucoSubMsg.data(4); arucoSubMsg.data(5)] / 1000.0 ) - p1);
            theta1 = theta1 + arucoSubMsg.data(6) - theta1;
        end
    end
    
    pl_dot = [vl*cos(thetal); vl*sin(thetal)];
    thetal_dot = wl;
    
    pl = pl + pl_dot * dt;
    thetal = thetal + thetal_dot*dt;
    
    %% Change to next objective point
    if abs(d_l) < 0.02  
       counter = rem(counter,length(x_path))+1;
    end
    
    send(twistPub1, twistMsg1);
    send(twistPub2, twistMsg2);
    
    % dt = toc;
    % tic
    t = dt + t;
    
    figure(1)
    scatter(p1(1),p1(2),'color','blue','LineWidth',2);
    hold on
    scatter(p2(1),p2(2),'color','red','LineWidth',2);
    scatter(pl(1),pl(2),'color','black','LineWidth',2);
    scatter(pd1(1),pd1(2),'color','green','LineWidth',1);
    scatter(pd2(1),pd2(2),'color','green','LineWidth',1);
    plot([p1(1),p1(1)+0.1*cos(theta1)],[p1(2),p1(2)+0.1*sin(theta1)],'color','red','LineWidth',2)
    plot([p2(1),p2(1)+0.1*cos(theta2)],[p2(2),p2(2)+0.1*sin(theta2)],'color','red','LineWidth',2)
    plot([pl(1),pl(1)+0.1*cos(thetal)],[pl(2),pl(2)+0.1*sin(thetal)],'color','red','LineWidth',2)
    
    hold off
    grid on
    axis([-2,2,-2,2]);
end

% Clean up
clear movementNode twistPub twistMsg;

function [orientation] = complementary_filter(yaw_aruco, yaw_odom, alpha)
        orientation = alpha * yaw_aruco + (1 - alpha) * yaw_odom;
end

